// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ADDRESSCHUNK_E6_FLATBUFFERS_ADDRESSCHUNK_H_
#define FLATBUFFERS_GENERATED_ADDRESSCHUNK_E6_FLATBUFFERS_ADDRESSCHUNK_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace e6 {
namespace flatbuffers {
namespace addressChunk {

struct Int64Vector;
struct Int64VectorBuilder;

struct Int32Vector;
struct Int32VectorBuilder;

struct Chunk;
struct ChunkBuilder;

enum Vector : uint8_t {
  Vector_NONE = 0,
  Vector_Int64Vector = 1,
  Vector_Int32Vector = 2,
  Vector_MIN = Vector_NONE,
  Vector_MAX = Vector_Int32Vector
};

inline const Vector (&EnumValuesVector())[3] {
  static const Vector values[] = {
    Vector_NONE,
    Vector_Int64Vector,
    Vector_Int32Vector
  };
  return values;
}

inline const char * const *EnumNamesVector() {
  static const char * const names[4] = {
    "NONE",
    "Int64Vector",
    "Int32Vector",
    nullptr
  };
  return names;
}

inline const char *EnumNameVector(Vector e) {
  if (::flatbuffers::IsOutRange(e, Vector_NONE, Vector_Int32Vector)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVector()[index];
}

template<typename T> struct VectorTraits {
  static const Vector enum_value = Vector_NONE;
};

template<> struct VectorTraits<e6::flatbuffers::addressChunk::Int64Vector> {
  static const Vector enum_value = Vector_Int64Vector;
};

template<> struct VectorTraits<e6::flatbuffers::addressChunk::Int32Vector> {
  static const Vector enum_value = Vector_Int32Vector;
};

bool VerifyVector(::flatbuffers::Verifier &verifier, const void *obj, Vector type);
bool VerifyVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Int64Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int64VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_NULLSET = 6,
    VT_DATA_LENGTH = 8
  };
  int64_t data() const {
    return GetField<int64_t>(VT_DATA, 0);
  }
  int64_t nullset() const {
    return GetField<int64_t>(VT_NULLSET, 0);
  }
  int64_t data_length() const {
    return GetField<int64_t>(VT_DATA_LENGTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DATA, 8) &&
           VerifyField<int64_t>(verifier, VT_NULLSET, 8) &&
           VerifyField<int64_t>(verifier, VT_DATA_LENGTH, 8) &&
           verifier.EndTable();
  }
};

struct Int64VectorBuilder {
  typedef Int64Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(int64_t data) {
    fbb_.AddElement<int64_t>(Int64Vector::VT_DATA, data, 0);
  }
  void add_nullset(int64_t nullset) {
    fbb_.AddElement<int64_t>(Int64Vector::VT_NULLSET, nullset, 0);
  }
  void add_data_length(int64_t data_length) {
    fbb_.AddElement<int64_t>(Int64Vector::VT_DATA_LENGTH, data_length, 0);
  }
  explicit Int64VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int64Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int64Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int64Vector> CreateInt64Vector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data = 0,
    int64_t nullset = 0,
    int64_t data_length = 0) {
  Int64VectorBuilder builder_(_fbb);
  builder_.add_data_length(data_length);
  builder_.add_nullset(nullset);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Int32Vector FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int32VectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_NULLSET = 6,
    VT_DATA_LENGTH = 8
  };
  int64_t data() const {
    return GetField<int64_t>(VT_DATA, 0);
  }
  int64_t nullset() const {
    return GetField<int64_t>(VT_NULLSET, 0);
  }
  int64_t data_length() const {
    return GetField<int64_t>(VT_DATA_LENGTH, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DATA, 8) &&
           VerifyField<int64_t>(verifier, VT_NULLSET, 8) &&
           VerifyField<int64_t>(verifier, VT_DATA_LENGTH, 8) &&
           verifier.EndTable();
  }
};

struct Int32VectorBuilder {
  typedef Int32Vector Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(int64_t data) {
    fbb_.AddElement<int64_t>(Int32Vector::VT_DATA, data, 0);
  }
  void add_nullset(int64_t nullset) {
    fbb_.AddElement<int64_t>(Int32Vector::VT_NULLSET, nullset, 0);
  }
  void add_data_length(int64_t data_length) {
    fbb_.AddElement<int64_t>(Int32Vector::VT_DATA_LENGTH, data_length, 0);
  }
  explicit Int32VectorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32Vector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32Vector>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32Vector> CreateInt32Vector(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data = 0,
    int64_t nullset = 0,
    int64_t data_length = 0) {
  Int32VectorBuilder builder_(_fbb);
  builder_.add_data_length(data_length);
  builder_.add_nullset(nullset);
  builder_.add_data(data);
  return builder_.Finish();
}

struct Chunk FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChunkBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VECTORS_TYPE = 4,
    VT_VECTORS = 6
  };
  const ::flatbuffers::Vector<uint8_t> *vectors_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_VECTORS_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *vectors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_VECTORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTORS_TYPE) &&
           verifier.VerifyVector(vectors_type()) &&
           VerifyOffset(verifier, VT_VECTORS) &&
           verifier.VerifyVector(vectors()) &&
           VerifyVectorVector(verifier, vectors(), vectors_type()) &&
           verifier.EndTable();
  }
};

struct ChunkBuilder {
  typedef Chunk Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_vectors_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> vectors_type) {
    fbb_.AddOffset(Chunk::VT_VECTORS_TYPE, vectors_type);
  }
  void add_vectors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> vectors) {
    fbb_.AddOffset(Chunk::VT_VECTORS, vectors);
  }
  explicit ChunkBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Chunk> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Chunk>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Chunk> CreateChunk(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> vectors_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> vectors = 0) {
  ChunkBuilder builder_(_fbb);
  builder_.add_vectors(vectors);
  builder_.add_vectors_type(vectors_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Chunk> CreateChunkDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vectors_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *vectors = nullptr) {
  auto vectors_type__ = vectors_type ? _fbb.CreateVector<uint8_t>(*vectors_type) : 0;
  auto vectors__ = vectors ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*vectors) : 0;
  return e6::flatbuffers::addressChunk::CreateChunk(
      _fbb,
      vectors_type__,
      vectors__);
}

inline bool VerifyVector(::flatbuffers::Verifier &verifier, const void *obj, Vector type) {
  switch (type) {
    case Vector_NONE: {
      return true;
    }
    case Vector_Int64Vector: {
      auto ptr = reinterpret_cast<const e6::flatbuffers::addressChunk::Int64Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Vector_Int32Vector: {
      auto ptr = reinterpret_cast<const e6::flatbuffers::addressChunk::Int32Vector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVectorVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVector(
        verifier,  values->Get(i), types->GetEnum<Vector>(i))) {
      return false;
    }
  }
  return true;
}

inline const e6::flatbuffers::addressChunk::Chunk *GetChunk(const void *buf) {
  return ::flatbuffers::GetRoot<e6::flatbuffers::addressChunk::Chunk>(buf);
}

inline const e6::flatbuffers::addressChunk::Chunk *GetSizePrefixedChunk(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<e6::flatbuffers::addressChunk::Chunk>(buf);
}

inline bool VerifyChunkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<e6::flatbuffers::addressChunk::Chunk>(nullptr);
}

inline bool VerifySizePrefixedChunkBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<e6::flatbuffers::addressChunk::Chunk>(nullptr);
}

inline void FinishChunkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<e6::flatbuffers::addressChunk::Chunk> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedChunkBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<e6::flatbuffers::addressChunk::Chunk> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace addressChunk
}  // namespace flatbuffers
}  // namespace e6

#endif  // FLATBUFFERS_GENERATED_ADDRESSCHUNK_E6_FLATBUFFERS_ADDRESSCHUNK_H_
